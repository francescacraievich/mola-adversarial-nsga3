{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Multi-Objective Adversarial Perturbations for SLAM Systems","text":"<p>Welcome to the documentation for the MOLA Adversarial NSGA-III project.</p>"},{"location":"#overview","title":"Overview","text":"<p>This project applies NSGA-III (Non-dominated Sorting Genetic Algorithm III) to evolve adversarial perturbations on LiDAR point clouds that can compromise SLAM (Simultaneous Localization and Mapping) systems. The project implements state-of-the-art adversarial attack techniques.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start</li> <li>Perturbation Strategies</li> <li>Fitness Evaluation</li> <li>API Reference</li> <li>Baseline</li> </ul>"},{"location":"#repository","title":"Repository","text":"<p>View the source code on GitHub.</p>"},{"location":"api/overview/","title":"API Reference","text":""},{"location":"api/overview/#overview","title":"Overview","text":"<p>This document provides an API reference for the main modules in the MOLA Adversarial NSGA-III project.</p>"},{"location":"api/overview/#modules","title":"Modules","text":""},{"location":"api/overview/#perturbation-generator","title":"Perturbation Generator","text":"<p>Location: <code>src/perturbations/perturbation_generator.py</code></p> <p>The <code>PerturbationGenerator</code> class implements state-of-the-art adversarial perturbation techniques for LiDAR point clouds.</p>"},{"location":"api/overview/#key-methods","title":"Key Methods","text":"Method Description <code>get_genome_size()</code> Returns genome size (17 parameters) <code>encode_perturbation(genome)</code> Converts genome to perturbation parameters <code>apply_perturbation(cloud, params, seed)</code> Applies perturbation to point cloud <code>compute_chamfer_distance(cloud1, cloud2)</code> Computes Chamfer distance between clouds <code>compute_curvature(points)</code> Computes local curvature for targeting <code>detect_edges_and_corners(points)</code> Detects edge/corner points (SLACK-inspired) <code>reset_temporal_state()</code> Resets temporal drift state"},{"location":"api/overview/#genome-structure-17-parameters","title":"Genome Structure (17 parameters)","text":"Index Parameter Range Description 0-2 Noise direction [-1, 1] Directional bias for noise 3 Noise intensity [0, 1] Scaled by <code>noise_std</code> 4 Curvature strength [0, 1] High-curvature targeting 5 Dropout rate [0, 1] Scaled by <code>max_dropout_rate</code> 6 Ghost ratio [0, 1] Scaled by <code>max_ghost_points_ratio</code> 7-9 Cluster direction [-1, 1] Direction for cluster perturbation 10 Cluster strength [0, 1] Cluster perturbation intensity 11 Spatial correlation [0, 1] Correlation of nearby perturbations 12 Geometric distortion [0, 1] ICP attack strength 13 Edge attack [0, 1] SLACK-inspired edge targeting 14 Temporal drift [0, 1] Accumulating drift strength 15 Scanline perturbation [0, 1] ASP-inspired attack 16 Strategic ghost [0, 1] Feature-based ghost placement"},{"location":"api/overview/#metrics","title":"Metrics","text":"<p>Location: <code>src/evaluation/metrics.py</code></p> <p>Functions for computing fitness metrics.</p>"},{"location":"api/overview/#functions","title":"Functions","text":"Function Description <code>compute_localization_error(gt, est, method)</code> Compute ATE/RPE between trajectories <code>compute_imperceptibility(orig, pert, method)</code> Compute perturbation magnitude <code>compute_multi_objective_fitness(...)</code> Combined fitness for NSGA-III <code>normalize_fitness(values, ref_point)</code> Normalize fitness values"},{"location":"api/overview/#ate-computation","title":"ATE Computation","text":"<p>The <code>_compute_ate</code> function implements standard Absolute Trajectory Error:</p> <ol> <li>Umeyama alignment: Rigid alignment (R + t, no scale) of estimated to ground truth</li> <li>RMSE: Root mean squared error of per-pose distances</li> </ol>"},{"location":"api/overview/#data-loaders","title":"Data Loaders","text":"<p>Location: <code>src/utils/data_loaders.py</code></p> <p>Functions for loading point clouds and trajectories.</p>"},{"location":"api/overview/#functions_1","title":"Functions","text":"Function Description <code>load_point_clouds_from_npy(path)</code> Load point cloud sequence <code>load_timestamps_from_npy(path)</code> Load frame timestamps <code>load_trajectory_from_tum(path, ...)</code> Load trajectory (TUM or NPY format)"},{"location":"api/overview/#nsga-iii-optimizer","title":"NSGA-III Optimizer","text":"<p>Location: <code>src/optimization/run_nsga3.py</code></p> <p>Main optimization script using pymoo's NSGA-III algorithm.</p>"},{"location":"api/overview/#key-classes","title":"Key Classes","text":"<p>MOLAEvaluator: ROS2 node that evaluates genomes by running MOLA SLAM.</p>"},{"location":"api/overview/#command-line-arguments","title":"Command Line Arguments","text":"<pre><code>python src/optimization/run_nsga3.py \\\n    --gt-traj maps/ground_truth_interpolated.npy \\\n    --frames data/frame_sequence.npy \\\n    --pop-size 10 \\\n    --n-gen 20 \\\n    --max-point-shift 0.05 \\\n    --noise-std 0.015 \\\n    --max-dropout 0.15 \\\n    --output src/results/optimized_genome.npy\n</code></pre>"},{"location":"api/overview/#baseline-ate","title":"Baseline ATE","text":"<p>Location: <code>src/baseline/baseline_ate.py</code></p> <p>Script for measuring baseline ATE with zero perturbation.</p> <pre><code>python src/baseline/baseline_ate.py --num-runs 3\n</code></pre> <p>Runs MOLA SLAM on unperturbed data to establish the baseline ATE (~23cm).</p>"},{"location":"api/overview/#preprocessing","title":"Preprocessing","text":""},{"location":"api/overview/#extract-frames-from-bag","title":"Extract Frames from Bag","text":"<p>Location: <code>src/preprocessing_data/extract_frames_and_tf_from_bag.py</code></p> <p>Extracts point cloud frames and TF transforms from ROS2 bag files.</p> <pre><code>python src/preprocessing_data/extract_frames_and_tf_from_bag.py \\\n    --bag bags/carter_lidar \\\n    --lidar-topic /carter/lidar \\\n    --output-frames data/frame_sequence.npy \\\n    --output-tf data/tf_sequence.npy \\\n    --output-tf-static data/tf_static.npy\n</code></pre>"},{"location":"api/overview/#create-frame-sequence","title":"Create Frame Sequence","text":"<p>Location: <code>src/preprocessing_data/create_frame_sequence.py</code></p> <p>Creates frame sequences from extracted data.</p>"},{"location":"api/overview/#plotting","title":"Plotting","text":""},{"location":"api/overview/#pareto-front-visualization","title":"Pareto Front Visualization","text":"<p>Location: <code>src/plots/plot_nsga3_results.py</code></p> <p>Visualization of optimization results showing Pareto front.</p> <pre><code>python src/plots/plot_nsga3_results.py src/results/optimized_genome12\n</code></pre> <p>Generates: - Pareto front plot (ATE vs Chamfer distance) - Valid evaluations scatter plot - Baseline reference line - Best solution statistics</p>"},{"location":"api/overview/#parameter-analysis","title":"Parameter Analysis","text":"<p>Location: <code>src/plots/plot_parameter_dual_correlation.py</code></p> <p>Analysis of genome parameter importance and correlation with fitness.</p> <p>Generates: - Parameter importance ranking - Dual correlation analysis (ATE and Chamfer distance)</p>"},{"location":"api/overview/#trajectory-comparison","title":"Trajectory Comparison","text":"<p>Location: <code>src/plots/compare_trajectories.py</code></p> <p>Compares ground truth and estimated trajectories visually.</p>"},{"location":"api/overview/#ros2-nodes","title":"ROS2 Nodes","text":""},{"location":"api/overview/#add-intensity-node","title":"Add Intensity Node","text":"<p>Location: <code>src/rover_isaacsim/carter_mola_slam/scripts/add_intensity_node.py</code></p> <p>ROS2 node that adds intensity field to point clouds from Isaac Sim.</p>"},{"location":"api/overview/#perturbation-node","title":"Perturbation Node","text":"<p>Location: <code>src/rover_isaacsim/carter_mola_slam/scripts/perturbation_node.py</code></p> <p>ROS2 node for real-time perturbation injection.</p>"},{"location":"api/overview/#point-cloud-comparison-node","title":"Point Cloud Comparison Node","text":"<p>Location: <code>src/rover_isaacsim/carter_mola_slam/scripts/pointcloud_comparison_node.py</code></p> <p>ROS2 node for comparing original and perturbed point clouds.</p>"},{"location":"api/overview/#references","title":"References","text":"<ul> <li>NSGA-III: Deb &amp; Jain (2014) - Reference-point based NSGA</li> <li>SLACK: arXiv 2024 - Attacking LiDAR-based SLAM</li> <li>ICP Attack: arXiv 2403.05666 - ICP adversarial perturbations</li> <li>ASP: IEEE 2024 - Attribution-based Scanline Perturbation</li> <li>FLAT: ECCV 2024 - Flux-Aware Imperceptible Adversarial Attacks</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>ROS 2 Jazzy</li> <li>Python 3.11 or higher</li> <li>NVIDIA Isaac Sim</li> <li>MOLA SLAM library</li> <li>pip package manager</li> <li>Git</li> </ul>"},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/francescacraievich/mola-adversarial-nsga3.git\ncd mola-adversarial-nsga3\n</code></pre>"},{"location":"getting-started/installation/#setup-virtual-environment","title":"Setup Virtual Environment","text":"<pre><code># Create virtual environment\npython3 -m venv .venv\n\n# Activate virtual environment\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#install-python-dependencies","title":"Install Python Dependencies","text":"<pre><code># Install core dependencies\npip install -r requirements/requirements.txt\n</code></pre> <p>The main dependencies are: - <code>numpy&gt;=1.24.0</code> - Numerical computing - <code>scipy&gt;=1.10.0</code> - Scientific computing (for KDTree) - <code>pymoo&gt;=0.6.0</code> - Multi-objective optimization (NSGA-III) - <code>matplotlib&gt;=3.7.0</code> - Visualization - <code>rosbags&gt;=0.9.0</code> - ROS bag file reading - <code>pytest&gt;=7.0.0</code> - Testing framework - <code>pytest-cov&gt;=4.0.0</code> - Code coverage</p>"},{"location":"getting-started/installation/#install-ros-2-dependencies","title":"Install ROS 2 Dependencies","text":"<pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Install MOLA SLAM\nsudo apt install ros-jazzy-mola-lidar-odometry\n\n# Install mp2p_icp for trajectory export\n# (follow MOLA installation guide)\n</code></pre>"},{"location":"getting-started/installation/#install-isaac-sim","title":"Install Isaac Sim","text":"<p>Refer to the NVIDIA Isaac Sim documentation for installation instructions.</p> <p>Required components: - Isaac Sim base installation - Carter robot asset - LiDAR sensor support</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code># Activate virtual environment\nsource .venv/bin/activate\n\n# Test Python dependencies\npython -c \"import numpy; import scipy; import pymoo; print('Python deps OK')\"\n\n# Test ROS 2 setup\nsource /opt/ros/jazzy/setup.bash\nros2 pkg list | grep mola\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation, proceed to the Quickstart Guide to: 1. Collect data in Isaac Sim 2. Extract point clouds from bag files 3. Run NSGA-III optimization 4. Analyze results</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through collecting data in Isaac Sim, running NSGA-III optimization, and analyzing the results.</p>"},{"location":"getting-started/quickstart/#overview","title":"Overview","text":"<p>The complete workflow consists of: 1. Data collection in Isaac Sim (simulated robot with LiDAR) 2. Extracting point clouds from ROS2 bag files 3. Exporting ground truth trajectory 4. Running NSGA-III optimization to find adversarial perturbations 5. Analyzing results and visualizing Pareto front</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have completed the Installation steps: - ROS 2 Jazzy installed and sourced - Python virtual environment activated - MOLA SLAM installed - Isaac Sim installed</p>"},{"location":"getting-started/quickstart/#step-1-data-collection-in-isaac-sim","title":"Step 1: Data Collection in Isaac Sim","text":"<p>Data collection requires running 5 terminals simultaneously. The robot navigates autonomously while collecting LiDAR data.</p>"},{"location":"getting-started/quickstart/#terminal-1-isaac-sim","title":"Terminal 1: Isaac Sim","text":"<pre><code># Launch Isaac Sim (adjust path to your installation)\n~/.local/share/ov/pkg/isaac-sim-4.2.0/isaac-sim.sh\n</code></pre> <p>In Isaac Sim: 1. Open the scene with the Carter robot 2. Start the simulation</p>"},{"location":"getting-started/quickstart/#terminal-2-ros2-bag-recording","title":"Terminal 2: ROS2 Bag Recording","text":"<pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Create bags directory if it doesn't exist\nmkdir -p bags\n\n# Record LiDAR topic\nros2 bag record -o bags/carter_lidar /carter/lidar\n</code></pre>"},{"location":"getting-started/quickstart/#terminal-3-add-intensity-node","title":"Terminal 3: Add Intensity Node","text":"<pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Activate virtual environment\nsource .venv/bin/activate\n\n# Run intensity node to add intensity field to point clouds\npython src/rover_isaacsim/carter_mola_slam/scripts/add_intensity_node.py\n</code></pre> <p>This node subscribes to <code>/carter/lidar</code> and republishes to <code>/carter/lidar_with_intensity</code>, adding the intensity field that MOLA expects.</p>"},{"location":"getting-started/quickstart/#terminal-4-mola-slam","title":"Terminal 4: MOLA SLAM","text":"<pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Run MOLA LiDAR odometry\nros2 launch mola_lidar_odometry ros2-lidar-odometry.launch.py \\\n  lidar_topic_name:=/carter/lidar_with_intensity \\\n  use_mola_gui:=True\n</code></pre> <p>MOLA will process the LiDAR scans and estimate the robot's trajectory in real-time.</p>"},{"location":"getting-started/quickstart/#terminal-5-trajectory-recording","title":"Terminal 5: Trajectory Recording","text":"<pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Record estimated trajectory\nros2 bag record -o bags/mola_trajectory /mola_estimated_trajectory\n</code></pre>"},{"location":"getting-started/quickstart/#stop-recording","title":"Stop Recording","text":"<p>After the robot completes its navigation: 1. Stop all ROS2 bag recordings (Ctrl+C) 2. Stop MOLA (Ctrl+C) 3. Stop the intensity node (Ctrl+C) 4. Stop Isaac Sim simulation</p> <p>You should now have two bag files: - <code>bags/carter_lidar/</code> - Contains LiDAR point clouds - <code>bags/mola_trajectory/</code> - Contains MOLA's estimated trajectory</p>"},{"location":"getting-started/quickstart/#step-2-extract-point-clouds-from-bag-file","title":"Step 2: Extract Point Clouds from Bag File","text":"<p>Convert ROS2 bag to numpy format for preprocessing:</p> <pre><code># Activate virtual environment\nsource .venv/bin/activate\n\n# Extract point clouds and transforms\npython src/preprocessing_data/extract_frames_and_tf_from_bag.py \\\n  --bag bags/carter_lidar \\\n  --lidar-topic /carter/lidar \\\n  --output-frames data/frame_sequence.npy \\\n  --output-tf data/tf_sequence.npy \\\n  --output-tf-static data/tf_static.npy\n</code></pre> <p>This creates: - <code>data/frame_sequence.npy</code> - List of point cloud arrays (N, 4) with xyzi coordinates - <code>data/frame_sequence.timestamps.npy</code> - Timestamps for each frame in nanoseconds - <code>data/tf_sequence.npy</code> - TF transforms - <code>data/tf_static.npy</code> - Static TF transforms</p>"},{"location":"getting-started/quickstart/#step-3-export-ground-truth-trajectory","title":"Step 3: Export Ground Truth Trajectory","text":"<p>MOLA saves the trajectory in its internal format. Export it to TUM format for evaluation:</p> <pre><code># Source ROS 2\nsource /opt/ros/jazzy/setup.bash\n\n# Export trajectory (adjust paths as needed)\nmp2p_icp_log_to_tum \\\n  --input-log bags/mola_trajectory/trajectory.log \\\n  --output data/ground_truth.tum\n</code></pre> <p>The TUM format contains: <code>timestamp tx ty tz qx qy qz qw</code></p> <p>Alternatively, if MOLA saved the map: <pre><code># Convert MOLA map to trajectory\nmp2p_icp_map_to_tum \\\n  --input-map maps/slam_output.mm \\\n  --output data/ground_truth.tum\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-4-run-nsga-iii-optimization","title":"Step 4: Run NSGA-III Optimization","text":"<p>Now you can run the optimization to find adversarial perturbations:</p> <pre><code># Activate virtual environment\nsource .venv/bin/activate\n\n# Run NSGA-III (400 evaluations: 20 generations \u00d7 20 population)\npython src/optimization/run_nsga3.py --n-gen 20 --pop-size 20\n</code></pre> <p>This will: 1. Load point clouds from <code>data/frame_sequence.npy</code> 2. Load timestamps from <code>data/frame_sequence.timestamps.npy</code> 3. Load ground truth from <code>data/ground_truth.tum</code> 4. Run NSGA-III optimization to find perturbations that maximize ATE 5. Save results to <code>src/results/optimized_genome.npy</code></p> <p>The optimization takes several hours depending on your hardware.</p>"},{"location":"getting-started/quickstart/#quick-test-run","title":"Quick Test Run","text":"<p>For testing, use fewer evaluations: <pre><code># 4 evaluations: 2 generations \u00d7 2 population\npython src/optimization/run_nsga3.py --n-gen 2 --pop-size 2\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-5-analyze-results","title":"Step 5: Analyze Results","text":"<p>The optimization saves the Pareto front to <code>src/results/optimized_genomeN.npy</code>. Each subsequent run increments the number automatically.</p>"},{"location":"getting-started/quickstart/#visualize-optimization-results","title":"Visualize Optimization Results","text":"<p>Plot the Pareto front:</p> <pre><code># Activate virtual environment\nsource .venv/bin/activate\n\n# Plot NSGA-III results\npython src/plots/plot_nsga3_results.py src/results/optimized_genome1\n</code></pre> <p>This creates visualizations showing: - Pareto front (ATE vs Chamfer distance) - Valid evaluations scatter plot - Baseline reference line</p>"},{"location":"getting-started/quickstart/#open-in-cloudcompare-optional","title":"Open in CloudCompare (Optional)","text":"<p>For detailed 3D visualization of point clouds:</p> <pre><code># Install CloudCompare if needed\nsudo snap install cloudcompare\n\n# Open point clouds (if you have .ply files)\ncloudcompare maps/*.ply\n</code></pre> <p>In CloudCompare: 1. Use point size 2-3 for better visibility 2. Color by intensity or height (Z coordinate) 3. Compare original vs perturbed frames side-by-side</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>After completing the quickstart: 1. Learn about Perturbation Strategies 2. Understand the Fitness Function 3. Review Baseline</p>"},{"location":"user-guide/baseline/","title":"Baseline Performance","text":""},{"location":"user-guide/baseline/#overview","title":"Overview","text":"<p>This document describes the expected baseline performance of MOLA SLAM on unperturbed data.</p>"},{"location":"user-guide/baseline/#baseline-ate-unperturbed-data","title":"Baseline ATE (Unperturbed Data)","text":"<p>Baseline ATE: ~23cm (0.23 meters)</p> <p>This is MOLA's natural localization error when processing clean, unperturbed LiDAR data from the Isaac Sim simulation.</p>"},{"location":"user-guide/baseline/#baseline-performance_1","title":"Baseline Performance","text":"<p>MOLA achieves ~23cm ATE on our test trajectory, which represents good SLAM performance:</p> <p>For comparison, typical MOLA performance: - Ideal conditions (real robot, optimized params): 10-20cm ATE - Good conditions (our case): 20-30cm ATE - Moderate conditions: 30-50cm ATE - Poor conditions (degraded sensors, fast motion): 50cm+ ATE</p>"},{"location":"user-guide/baseline/#baseline-characteristics","title":"Baseline Characteristics","text":"<p>Running MOLA on unperturbed data: - Frames processed: 113 frames (10Hz LiDAR) - Keyframes selected: 49 keyframes (MOLA selects when robot moves) - Trajectory length: ~11.3 seconds - Points per frame: ~50,000 points - Loop closures: 2-3 successful loop closures</p> <p>The baseline provides a reference point for measuring adversarial attack effectiveness.</p>"},{"location":"user-guide/fitness/","title":"Fitness Evaluation","text":""},{"location":"user-guide/fitness/#overview","title":"Overview","text":"<p>Fitness evaluation is the core of the NSGA-III optimization process. For each candidate solution (genome), we measure how well it achieves our two objectives: maximizing localization error while minimizing perturbation magnitude.</p> <p>This evaluation happens hundreds of times during optimization (750 evaluations in genome12), making it the most computationally expensive component of the system.</p>"},{"location":"user-guide/fitness/#two-objectives","title":"Two Objectives","text":""},{"location":"user-guide/fitness/#objective-1-maximize-localization-error-ate","title":"Objective 1: Maximize Localization Error (ATE)","text":"<p>The primary goal is to degrade MOLA's localization accuracy as much as possible. We measure this using Absolute Trajectory Error (ATE).</p> <p>ATE Definition: ATE is the root mean square error (RMSE) between the estimated trajectory and ground truth trajectory after optimal alignment.</p> <p>Interpretation: - Higher ATE = More trajectory error = Better attack - Baseline ATE \u2248 23cm (MOLA's natural error on unperturbed data) - Target ATE \u2248 65-85cm (after perturbations, +183% to +269%)</p> <p>NSGA-III tries to maximize this objective (internally stored as negative value).</p>"},{"location":"user-guide/fitness/#objective-2-minimize-perturbation-magnitude","title":"Objective 2: Minimize Perturbation Magnitude","text":"<p>The secondary goal is to keep perturbations as small as possible to avoid detection.</p> <p>Perturbation Magnitude: We use the Chamfer distance between original and perturbed point clouds as the imperceptibility metric. This measures how much the point cloud has changed in a way that accounts for both point displacement and structural changes.</p> <p>Interpretation: - Lower Chamfer distance = More stealthy = Better - Typical perturbations: 1-5cm Chamfer distance - Physical constraint: perturbations should remain below sensor noise levels</p> <p>NSGA-III tries to minimize this objective.</p>"},{"location":"user-guide/fitness/#evaluation-pipeline","title":"Evaluation Pipeline","text":"<p>For each genome in the population, the <code>MOLAEvaluator</code> class performs these steps:</p>"},{"location":"user-guide/fitness/#step-1-decode-genome","title":"Step 1: Decode Genome","text":"<p>The 17-parameter genome encodes multiple attack strategies simultaneously. The genome is a continuous array in range [-1, 1] that encodes:</p> <ul> <li>Parameters 0-2: Noise direction (3D vector)</li> <li>Parameter 3: Noise intensity</li> <li>Parameter 4: Curvature targeting strength</li> <li>Parameter 5: Dropout rate</li> <li>Parameter 6: Ghost point ratio</li> <li>Parameters 7-10: Cluster perturbation</li> <li>Parameter 11: Spatial correlation</li> <li>Parameter 12: Geometric distortion (ICP attack)</li> <li>Parameter 13: Edge attack strength</li> <li>Parameter 14: Temporal drift</li> <li>Parameter 15: Scanline perturbation</li> <li>Parameter 16: Strategic ghost placement</li> </ul>"},{"location":"user-guide/fitness/#step-2-generate-perturbed-sequence","title":"Step 2: Generate Perturbed Sequence","text":"<p>Apply perturbations to all point cloud frames:</p> <ol> <li>Apply the perturbation using <code>PerturbationGenerator.apply_perturbation()</code></li> <li>Compute Chamfer distance between original and perturbed cloud</li> <li>Accumulate for average Chamfer distance</li> </ol>"},{"location":"user-guide/fitness/#step-3-run-mola-slam","title":"Step 3: Run MOLA SLAM","text":"<p>Publish perturbed point clouds to ROS2 and run MOLA:</p> <ol> <li>Start MOLA process in background</li> <li>Publish clouds with synchronized timestamps and TF at 10Hz</li> <li>Collect trajectory from MOLA odometry output</li> </ol>"},{"location":"user-guide/fitness/#step-4-compute-ate","title":"Step 4: Compute ATE","text":"<p>Compare estimated trajectory with ground truth using the <code>compute_localization_error</code> function:</p> <ol> <li>Align trajectories using Umeyama algorithm</li> <li>Compute RMSE of position errors</li> </ol>"},{"location":"user-guide/fitness/#step-5-return-fitness","title":"Step 5: Return Fitness","text":"<p>Return both objectives: - First objective: negative ATE (pymoo minimizes, so we negate to maximize) - Second objective: perturbation magnitude (Chamfer distance)</p>"},{"location":"user-guide/fitness/#handling-invalid-solutions","title":"Handling Invalid Solutions","text":"<p>Some perturbations cause MOLA to fail completely:</p> <p>Failure cases: - Too much dropout: Not enough points for ICP - Extreme noise: Feature matching fails - MOLA process crashes</p> <p>Detection: If MOLA collects fewer than 40 trajectory points, the evaluation retries up to 2 times. If it still fails, the solution returns infinite fitness and is excluded from the Pareto front.</p>"},{"location":"user-guide/fitness/#baseline-performance","title":"Baseline Performance","text":"<p>Before optimization, we measure baseline ATE on unperturbed data:</p> <p>Baseline ATE: ~23cm</p> <p>This represents MOLA's natural localization error on clean Isaac Sim data.</p> <p>For reference:</p> ATE Interpretation Quality 0-30cm Excellent SLAM performance Professional-grade 30-60cm Good performance Acceptable for robotics 60-100cm Moderate drift Usable but degraded 100-150cm Significant drift Unreliable localization 150cm+ Severe failure Unusable"},{"location":"user-guide/fitness/#results-genome-12-750-evaluations","title":"Results (Genome 12 - 750 evaluations)","text":"<p>Optimization Results: - Total evaluations: 750 - Valid evaluations: 347 (46%) - Pareto-optimal solutions: 32</p> <p>Best Solutions:</p> Strategy ATE Perturbation Degradation Aggressive 85cm 4.6cm +269% Balanced 65cm 3.5cm +183% Moderate 44cm 2.0cm +91% Stealthy 27cm 1.0cm +17% <p>Most Effective Parameters: - Temporal drift: Strongest correlation with ATE increase - Scanline perturbation: Second most effective - Geometric distortion: High impact on ICP alignment</p>"},{"location":"user-guide/fitness/#efficiency-metric","title":"Efficiency Metric","text":"<p>Beyond absolute ATE, we care about efficiency: how much ATE per unit of perturbation?</p> <p>Efficiency = (ATE - baseline_ATE) / perturbation_magnitude</p> <p>Example from genome12: - Solution A: ATE=85cm, pert=4.6cm \u2192 efficiency = (85-23)/4.6 = 13.5 cm/cm - Solution B: ATE=65cm, pert=3.5cm \u2192 efficiency = (65-23)/3.5 = 12.0 cm/cm</p>"},{"location":"user-guide/fitness/#implementation","title":"Implementation","text":"<p>The fitness evaluator is implemented in <code>src/optimization/run_nsga3.py</code> as the <code>MOLAEvaluator</code> class, a ROS2 node that:</p> <ol> <li>Receives genome from NSGA-III optimizer</li> <li>Decodes genome to perturbation parameters</li> <li>Generates perturbed point cloud sequence</li> <li>Publishes to ROS2 topics</li> <li>Runs MOLA SLAM</li> <li>Collects trajectory and computes ATE</li> <li>Returns fitness tuple (negative ATE, Chamfer distance)</li> </ol> <p>The optimizer uses pymoo's NSGA-III with Das-Dennis reference directions.</p>"},{"location":"user-guide/perturbations/","title":"Perturbation Strategies","text":""},{"location":"user-guide/perturbations/#overview","title":"Overview","text":"<p>Adversarial perturbations are small, carefully crafted modifications to LiDAR point clouds that degrade SLAM performance while remaining imperceptible. This document describes the 17-parameter genome encoding and the effectiveness of each perturbation strategy against MOLA SLAM.</p> <p>The perturbation generator implements state-of-the-art adversarial techniques based on recent research:</p> <ul> <li>FLAT: Flux-Aware Imperceptible Adversarial Attacks (ECCV 2024)</li> <li>SLACK: Attacking LiDAR-based SLAM (arXiv 2024)</li> <li>ICP Attack: Adversarial attacks on ICP registration (arXiv 2403.05666)</li> <li>ASP: Attribution-based Scanline Perturbation (IEEE 2024)</li> </ul>"},{"location":"user-guide/perturbations/#attack-objectives","title":"Attack Objectives","text":"<p>An effective adversarial perturbation must balance two goals:</p> <ol> <li>Maximize localization error - Cause MOLA to produce inaccurate trajectory estimates</li> <li>Minimize detectability - Keep perturbations small enough to avoid detection</li> </ol> <p>The NSGA-III optimization finds perturbations that achieve the best trade-off between these objectives.</p>"},{"location":"user-guide/perturbations/#17-parameter-genome","title":"17-Parameter Genome","text":"<p>The genome encodes 17 continuous parameters in the range [-1, 1], which are then scaled to their respective physical ranges. Each parameter controls a different aspect of the perturbation.</p>"},{"location":"user-guide/perturbations/#basic-perturbations-parameters-0-6","title":"Basic Perturbations (Parameters 0-6)","text":""},{"location":"user-guide/perturbations/#parameters-0-2-noise-direction-3d-vector","title":"Parameters 0-2: Noise Direction (3D Vector)","text":"<p>A directional bias applied to all points.</p> <ul> <li>Parameter 0: X component of noise direction</li> <li>Parameter 1: Y component of noise direction</li> <li>Parameter 2: Z component of noise direction</li> </ul> <p>The direction vector is normalized and scaled by noise intensity. This creates a systematic drift in a specific direction rather than random noise.</p> <p>Why it works: Directional bias accumulates over time, causing consistent odometry drift that SLAM cannot correct without loop closures.</p>"},{"location":"user-guide/perturbations/#parameter-3-noise-intensity","title":"Parameter 3: Noise Intensity","text":"<p>Controls the magnitude of Gaussian noise added to point coordinates.</p> <ul> <li>Range: 0-5cm standard deviation</li> <li>ATE correlation: +0.370 (strong positive effect)</li> <li>Perturbation correlation: +0.366 (increases detectability)</li> </ul> <p>Why it works: Random noise degrades ICP point-to-plane alignment accuracy. Higher noise means less precise feature matching between consecutive frames.</p>"},{"location":"user-guide/perturbations/#parameter-4-curvature-targeting","title":"Parameter 4: Curvature Targeting","text":"<p>Targets high-curvature regions (edges, corners) with stronger perturbations.</p> <ul> <li>Range: 0-100% strength</li> <li>ATE correlation: +0.227 (moderate positive effect)</li> <li>Perturbation correlation: -0.025 (minimal impact on detectability)</li> </ul> <p>Why it works: SLAM systems rely on geometric features (edges, corners, planes) for alignment. Corrupting these features specifically degrades matching quality.</p>"},{"location":"user-guide/perturbations/#parameter-5-dropout-rate","title":"Parameter 5: Dropout Rate","text":"<p>Percentage of points randomly removed from each frame.</p> <ul> <li>Range: 0-30%</li> <li>ATE correlation: +0.055 (weak positive effect)</li> <li>Perturbation correlation: +0.105 (low detectability impact)</li> </ul> <p>Why it works: Removing points reduces feature density, degrading ICP convergence and loop closure detection. However, MOLA is relatively robust to moderate dropout.</p>"},{"location":"user-guide/perturbations/#parameter-6-ghost-point-ratio","title":"Parameter 6: Ghost Point Ratio","text":"<p>Adds synthetic points near real measurements.</p> <ul> <li>Range: 0-10% additional points</li> <li>ATE correlation: -0.086 (slightly negative effect)</li> <li>Perturbation correlation: +0.110 (increases detectability)</li> </ul> <p>Why it works: Ghost points create false correspondences in ICP. However, MOLA's outlier rejection often filters these, making this less effective.</p>"},{"location":"user-guide/perturbations/#cluster-perturbations-parameters-7-10","title":"Cluster Perturbations (Parameters 7-10)","text":""},{"location":"user-guide/perturbations/#parameters-7-9-cluster-direction-3d-vector","title":"Parameters 7-9: Cluster Direction (3D Vector)","text":"<p>Direction for cluster-based perturbations.</p> <ul> <li>Parameter 7: X component (ATE correlation: -0.261)</li> <li>Parameter 8: Y component (ATE correlation: +0.003)</li> <li>Parameter 9: Z component (ATE correlation: +0.036)</li> </ul>"},{"location":"user-guide/perturbations/#parameter-10-cluster-strength","title":"Parameter 10: Cluster Strength","text":"<p>Intensity of cluster-based perturbations.</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: +0.071 (weak positive effect)</li> <li>Perturbation correlation: -0.037 (minimal impact)</li> </ul> <p>Why it works: Clusters of points are shifted together, maintaining local structure while introducing global distortion.</p>"},{"location":"user-guide/perturbations/#advanced-perturbations-parameters-11-16","title":"Advanced Perturbations (Parameters 11-16)","text":""},{"location":"user-guide/perturbations/#parameter-11-spatial-correlation","title":"Parameter 11: Spatial Correlation","text":"<p>Controls how perturbations are correlated spatially.</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: -0.167 (negative effect)</li> <li>Perturbation correlation: -0.070 (reduces detectability)</li> </ul> <p>Why it works: Spatially correlated perturbations appear more natural than random noise. However, high correlation may actually help SLAM by preserving local structure.</p>"},{"location":"user-guide/perturbations/#parameter-12-geometric-distortion-icp-attack","title":"Parameter 12: Geometric Distortion (ICP Attack)","text":"<p>Applies systematic geometric distortions (scaling, shearing).</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: +0.357 (strong positive effect)</li> <li>Perturbation correlation: +0.970 (very high detectability!)</li> </ul> <p>Why it works: ICP assumes rigid transformations. Systematic distortions violate this assumption, causing alignment failures. However, this is highly detectable due to large point displacements.</p>"},{"location":"user-guide/perturbations/#parameter-13-edge-attack-slack-inspired","title":"Parameter 13: Edge Attack (SLACK-inspired)","text":"<p>Targets edge and corner points with perpendicular shifts.</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: +0.033 (weak positive effect)</li> <li>Perturbation correlation: -0.149 (reduces detectability)</li> </ul> <p>Why it works: Shifting edge points perpendicular to their principal direction maximizes ICP confusion while minimizing visible distortion.</p>"},{"location":"user-guide/perturbations/#parameter-14-temporal-drift","title":"Parameter 14: Temporal Drift","text":"<p>Accumulating bias across frames over time.</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: +0.627 (strongest positive effect!)</li> <li>Perturbation correlation: +0.237 (moderate detectability)</li> </ul> <p>Why it works: Temporal drift is the most effective attack because: - Bias accumulates consistently over the trajectory - Prevents loop closure detection (locations appear different over time) - SLAM cannot correct accumulated drift without recognizing revisited places</p>"},{"location":"user-guide/perturbations/#parameter-15-scanline-perturbation-asp-inspired","title":"Parameter 15: Scanline Perturbation (ASP-inspired)","text":"<p>Perturbs points along their laser beam directions.</p> <ul> <li>Range: 0-100%</li> <li>ATE correlation: +0.595 (second strongest effect!)</li> <li>Perturbation correlation: +0.392 (moderate-high detectability)</li> </ul> <p>Why it works: Perturbations along scanlines simulate realistic sensor interference (dust, particles). This systematically affects range measurements in a physically plausible way.</p>"},{"location":"user-guide/perturbations/#parameter-16-strategic-ghost-placement","title":"Parameter 16: Strategic Ghost Placement","text":"<p>Places ghost points near geometric features.</p> <ul> <li>Range: 0-100% (activates when &gt; 50%)</li> <li>ATE correlation: +0.344 (strong positive effect)</li> <li>Perturbation correlation: -0.026 (minimal detectability impact)</li> </ul> <p>Why it works: Ghost points placed near features create ambiguous correspondences that ICP cannot easily reject, unlike random ghost points.</p>"},{"location":"user-guide/perturbations/#effectiveness-rankings","title":"Effectiveness Rankings","text":"<p>Based on correlation analysis from genome12 results (347 valid evaluations):</p>"},{"location":"user-guide/perturbations/#most-effective-for-increasing-ate","title":"Most Effective for Increasing ATE","text":"Rank Parameter ATE Correlation Why Effective 1 Temporal Drift +0.627 Accumulates over time, breaks loop closure 2 Scanline Perturbation +0.595 Systematic range errors, physically realistic 3 Noise Intensity +0.370 Degrades ICP alignment precision 4 Geometric Distortion +0.357 Violates ICP rigid transformation assumption 5 Strategic Ghost +0.344 Creates ambiguous feature correspondences"},{"location":"user-guide/perturbations/#defending-against-perturbations","title":"Defending Against Perturbations","text":"<p>Understanding these attacks informs defense strategies:</p> <ol> <li>Temporal consistency checking: Detect sudden changes in point cloud statistics between frames</li> <li>Multi-sensor fusion: Combine LiDAR with camera or IMU for redundancy</li> <li>Learned anomaly detection: Train classifiers to detect adversarial patterns</li> <li>Robust loop closure: Use multiple verification methods for place recognition</li> <li>Range verification: Cross-check LiDAR ranges with expected environment geometry</li> </ol>"}]}